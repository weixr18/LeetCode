# Notes

## Trivial

### 1 两数之和

+ 题目
  + 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。
+ 思路
  + 带index排序 O(nlogn)
  + 带指针扫描 O(n)

### 866 回文素数

+ 题目
  + 求出大于或等于 N 的最小回文素数。
+ 思路
  1. 拿到最小回文基，依次递增找回文数
  2. 模6+方根法判断是否素数

### O07 重构二叉树

+ 题目
  + 先序遍历和中序遍历重构二叉树
+ 思路
  + 先序遍历最左侧为当前子树根节点。在中序遍历中看到该节点时，说明此时应该生长其右子树。
  + 用栈依次保存根节点。

## Medium

### 22 括号生成

+ 题目
  + 数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。
+ 思路
  + 等效成二维平面上等腰直角三角形内的曼哈顿寻路问题。
  + 用一个栈辅助，做深度优先搜索，遍历所有可能路径。

### 51 逆序对个数

+ 题目
  + 求给定数组逆序对个数
+ 思路
  + 归并排序 O(nlogn)

## Star

### O41 数据流中位数

+ 题目
  + 如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。
+ 思路
  + 双堆
    + 一个大顶堆保存较小的一半，一个小顶堆保存较大的一半
    + O(log n)

### O04 有序二维数组查找

+ 题目
  + 在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
+ 思路
  + 从右上角开始，大于往左，小于往下，等于返回true，走到左下角返回false。

### 53 最大子数组和

+ 题目
  + 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
+ 思路
  + **线段树**
    + 每个线段维护4个值：左起最大和，右起最大和，总最大和，总和，遍历更新即可。O(log n)

### 300 最长上升子序列

+ 题目
  + 给定一个无序的整数数组，找到其中最长上升子序列的长度。
+ 思路
  + O(n^2) DP
    + 每个位置存储一个数：以该位置数结尾的上升子序列的最大长度
    + 从前到后遍历[0,i]的位置，获取第i+1位置的最大长度
    + 所有最大长度之最大值即为解
  + **O(nlogn) 贪心二分**
    + 记录每个长度对应的上升子序列的最小终值
    + 对于第i个位置，要么增长最长可能长度（比所有最小终值都大），要么更新某个最小终值

### 523 连续的子数组和

+ 题目
  + 给定一个包含 非负数 的数组和一个目标 整数 k，编写一个函数来判断该数组**是否**含有连续的子数组，其大小至少为 2，且总和为 k 的倍数，即总和为 n*k，其中 n 也是一个整数。
+ 思路
  + 最暴力
    + 对所有可能求和，O(n^3)
  + less 暴力
    + 用O(n^2)空间保存之前的所有子组和，O(n^2)
  + **Hashmap**
    + 若有[a_i, a_j]连续和模k余0，则必有[0, a_i]和[0, a_j]模k相同。
    + 用Hashmap保存每一个从头开始的连续和模k余数，重复即确定含有。

### O39 超过一半的数字

+ 题目
  + 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。
+ 思路
  + Hash
    + 时间复杂度O(n) 空间复杂度O(n)
  + **摩尔投票法**
    + 众数票数为1，非众数票数为-1.由题，总票数为正
    + 若把某非众数的数当做众数
      + 当正负相消时，要么消了偶数票负数，要么消了0，即总票数仍为正，真正的众数仍为众数
      + 根据题目条件，一定可以相消
    + 因此可以无脑选众数，相消就换。最终剩下的数一定是众数。
